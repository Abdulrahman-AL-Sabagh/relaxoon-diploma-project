\setauthor{Abdulrahman Al Sabagh}
\section{\textbf{E}ntity \textbf{R}elationship \textbf{D}iagram (ERD)}

\begin{figure}[H]
  \centering
  \includegraphics[height=1\textwidth]{./pics/erd.png}
  \caption{ERD}

\end{figure}

\section{Wie werden Files gespeichert?}
Im diesem Kapitel wird genau erklärt, wie Strapi mit der Verwaltung von Files umgeht. Es wurde keine Dokumentation für die folgenden Informationen gefunden. Daher untersuchten die Entwickler das Datenmodell von  Strapi.
Man sieht oben in dem ERD,
dass die Bilder nicht in einer Spalte gespeichert werden. Strapi speichert die Informationen von den Files wie zum Beispiel Größe, Name und Auflösung in einer Tabelle namens ''files''.
Diese ist auch mit einer anderen Tabelle namens ''files\_realted\_morphs'' verbunden. In ''files\_related\_morphs'' wird der Name des Models gespeichert, welcher von Strapi verwendet wird, um die Daten in der Datenbank zu manipulieren. Das Id von dem Element, welches einen Zugriff auf die Datei benötigt wird auch in dieser Tabelle gespeichert.
Der Client kann dann die Files erst erhalten, wenn er das Parameter ''populate=file'' bei dem REST-Request daran hängt. Strapi manipuliert dann die Ergebnisse, sodass die gefragten Daten z.B.: Medias und die zugehörige Dateien eines Mediaelements im Responsebody zurückgeschickt werden können.

\section{Medias und Articles}

Grundsätzlich wurde als Team entschieden,
die Artikel und die Medien in zwei separaten Tabellen zu speichern,
da Artikel mehrere Bilder, Videos und AudIOS enthalten.
Diesen können dann mittels einem ''Rich Text Editor'' hinzugefügt werden.
Bei ''Media'' handelt es sich nur um ein Medienelement,
nämlich ein Bild, Video oder Audio File. Es ist aber wichtig anzumerken,
dass keine Benutzeroberfläche für die Artikel implementiert wurde, da der Auftraggeber
diese nicht in dem \textbf{M}inimal \textbf{V}iable \textbf{P}roduct (MVP) haben wollte.
Für die Realisierung des kompletten Datenmodells war aber das Einfügen der Artikel erforderlich.

\section{TutorialPage}
\label{Tutorial-Page}
Die Entität ''TutorialPage'' hat keine Beziehungen zu anderen Entitäten, da sie nur für den Inhalt der Tutorial-Slideshow,
die nach der erfolgreichen Installation der App angezeigt wird, gedacht ist.

\begin{figure}[H]
  \centering
  \includegraphics[height=0.5\textwidth]{./pics/slideshow.png}
  \caption{Screenshot aus dem UI Prototyp von Relaxoon}
\end{figure}

Das Team hat sich entschlossen, die Daten von dem Slideshow in einer Tabelle zu speichern.
Eine alternative Lösungsmöglichkeit besteht darin, die Daten des Slideshows in der Applikation hard zu codieren.
Das Team hat sich für die Persestierung der Daten entschieden, damit das Einpflegen der Inhalte nicht über die Applikation erfoglt.
Wenn das Team sich für die alternative Lösungsvariante entschieden hätte, müsste bei jeder kleinen Änderung ein neuer Android- bzw. IOS-Build erstellt werden.

\section{Suche und Filterungen}

Bei den Filterungen wurde der ''Interactive Query Builder'' verwendet,
um die Filterparameter der Abfragen zu generieren
und diese dann bei den REST Abfragen anzuhängen (Siehe \ref{subsec:rest} für mehrere Details).
Es gibt auch die Möglichkeit, die REST-Ressource im Backend mittels der
''Query Engine API'' oder mit dem Einstaz von der ''Entity Service API'' anzupassen.
Allerdings wurden die Rückgabedaten von der Endpoint gar nicht umgestellt,
da die Dokumentation bzw. Intellisense  des ''Query Engine API'' bzw. ''Entity Service API'' sehr ungenau waren.


\begin{lstlisting}[caption=Code von Interactive Query Builder]
  const queryParamFilter = qs.stringify(
    {
      filters: {
        $or: [
          {
            description: {
              $containsi: text
            }
          },
          {
            title: {
              $containsi: text
            }
          },
          {
            categories: {
              name: {
                $containsi: text
              }
            }
          },
          {
            tags: {
              name: {
                $containsi: text
              }
            }
          }
        ]
      }
    },
    { encodeValuesOnly: true }
  );
  
\end{lstlisting}
In dem obigen Codesnippet befindet sich der Code für die Suchleiste.
Es wird am Anfang entweder nach der Kategorie, nach dem Tag,
nach der Beschreibung oder nach dem Titel eines Videos gefiltert.
Wenn ein oder mehrere Treffer für diese Parameter gefunden werden,
werden sie im Responsebody zurückgegeben.
Die Groß und Kleinschreibung wird dabei gar nicht beachtet.


\textbf{API-Route mit den angehängten generierten Abfrageparametern}:
\newline
\textcolor{red}{/medias?\&populate[tags]=true
\&populate[file]=true
\&populate[favorite][populate]=\newline users\_permissions\_user}

Damit man sicherstellt, ob die generierten Parameter richtig sind, wurde folgende Ansicht von Postman verwendet:
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{./pics/postman.png}
  \caption{Ansicht von Postman}

\end{figure}


\section{State Management}
''Der Begriff State ist in React-Applikationen überall präsent. Generell
bezeichnet State den Zustand einer Komponente,
also die dynamischen Daten, die eine Komponente den Benutzer:innen anzeigt.
Eine Änderung am State führt dazu, dass die Komponente neu gerendert wird
und so die Datenänderung für die Benutzer:in sichtbar wird.
Im einfachsten Fall verwaltet jede Komponente ihren eigenen State.
Es gibt Fälle, in denen es jedoch erforderlich wird,
den State zwischen mehreren Komponenten zu teilen.
''
\cite{state-management}

Um die Zustände der Applikation zu behandeln wurde meistens mit dem ''useState Hook'' von React gearbeitet.
Der Einsatz einer State Management Library wie zum Beispiel ''RXJS'' oder ''Redux'' war gar nicht nötig, da die Anzahl der verwendeten UI-Komponenten nicht so groß ist.

\subsection{useState Hook}
``useState is a React Hook that lets you add a state variable to your component.'' \cite{useState}


\section{Dark/Light Mode}
Da das Team sich für die Verwendung von der UI-Library ''Native Base'' entschieden hat, war die Realisierung dieses Features sehr einfach.
Die Komponenten von Native Base haben die Properties \_light und \_dark, sodass man die Farbe einer Komponente je nach Modus definieren kann.
Native Base verwendet im Hintergrund einen useContext Hook, in dem die Modi der Applikation gespeichert werden.
\subsection{useContext Hook}
''useContext is a React hook that provides a way to share data (context)
across multiple components without explicitly passing it through props.
It is part of the React Context API, which is built into the React library.
'' \cite{useContext}






\section{Help und Info Screen}

Für die gleichen Gründe, welche in dem Unterkapitel \ref{Tutorial-Page} genannt wurden, wurden die Daten dieser zwei Ansichten in einem Single Type (Siehe  \ref{single-types}) gespeichert.


\section{Authentifizierung}
Für die Authentifizierung wurde mit Json Web Token (JWT) gearbeitet. Die Authentifizierungslogik im Server ist im Strapi eingebaut. Für den Client wurde die Logik so umgesetzt, dass der User:in die App erst verwenden kann, wenn er bereits authentifiziert ist.
Die Ansicht fürs Login soll aber nicht angezeigt werden, wenn der User:in bereits authentifiziert ist.
Um zu überprüfen, ob der Nutzer:in noch eingeloggt ist oder nicht, wurde der Token im AsyncStorage gespeichert. Dieser ist ähnlich zu dem localStorage in der Webentwicklung. Somit wurde bei der Öffnung der App geprüft, ob der Token valid und nicht abgelaufen ist.
Damit der User:in auf die anderen Screens nicht zugreifen kann, wenn er nicht eingeloggt ist, wurde eine boolische Zustandsvariable verwendet, welche das LoginScreen als die zweite Ebene unserer Stack-Navigation rendert, wenn der Token invalid oder abgelaufen ist. Die erste Ebene ist für den TutorialScreen reserviert.
Im folgenden Codestück ist die ganze Logik der Authentifizierung zu finden:
\begin{lstlisting}[caption=protected screens]
 
  // Screen names
  type PageSettings = Record<string, { iconName: string; screen: React.ComponentType<any> }>;
  const settingsForScreenName: PageSettings = {
    Home: { iconName: 'home', screen: HomeScreen },
    Media: { iconName: 'play', screen: CategoryScreen },
    Saved: { iconName: 'list', screen: SavedScreen }
  };
  
  const Tab = createBottomTabNavigator();
  const Stack = createStackNavigator();
  
  function MainContainer(): JSX.Element {
    const { colorMode } = useColorMode();
    const [tokenExists, setTokenExists] = useState<boolean>(false);
    useEffect(() => {
      getToken()
        .then((data) => {
          console.info(typeof data);
          if (!data) throw new Error('no token');
          const decodedToken: { iat: number; exp: number; id: number } = jwtDecode(data);
          const eighthoursAfterNow = new Date(new Date().getHours() + 8).getMilliseconds();
          if (decodedToken.exp < eighthoursAfterNow) {
            setTokenExists(false);
            AsyncStorage.clear();
            return;
          }
          setTokenExists(true);
        })
        .catch((e) => {
          console.info('no token', e);
          setTokenExists(false);
        });
      console.info(tokenExists);
    }, []);
  
    return (
      <Stack.Navigator
        screenOptions={{
          headerShown: false
        }}
      >
        {/*
        <Stack.Screen name={"WaitScreen"} component={WaitScreen}/>
  */}
        {/*
        {!tokenExists && <Stack.Screen name="Tutorial" component={TutorialScreen}/>}
  */}
        {!tokenExists && <Stack.Screen name="Login" component={LoginScreen} />}
        {!tokenExists && <Stack.Screen name="Registration" component={RegistrationForm} />}
        <Stack.Screen
          name="Main"
          options={{
            headerShown: false
          }}
        >
          {() => (
            <Tab.Navigator
              screenOptions={{
                headerShown: false,
                headerTitleStyle: {
                  fontSize: 16,
                  color: colorMode === 'dark' ? colors.fontDark : colors.fontLight
                }
              }}
              tabBar={(props) => <TabBar color={colorMode} {...props} />}
            >
              {Object.entries(settingsForScreenName).map(([pageName, settings]) => (
                <Tab.Screen key={pageName} name={pageName} component={settings.screen} />
              ))}
            </Tab.Navigator>
          )}
        </Stack.Screen>
        <Stack.Screen name="Content" component={MediaScreen} />
        <Stack.Screen component={VideoScreen} name="Video" />
        <Stack.Screen component={SettingsScreen} name="Settings" />
        <Stack.Screen name="Info" component={InfoScreen} />
        <Stack.Screen name="Help" component={HelpScreen} />
      </Stack.Navigator>
    );
  }
  
  export default MainContainer;
    
\end{lstlisting}

\section{Validierung}
Strapi an sich hat eine eingebaute Validierung für Emails und Passwörter. Das Team hat aber eine client-seitige Validierung implementiert, um die Anzahl der Requests zu minimieren und eine bessere UX zu schaffen.
Für die client-seitige Validierung wurde eine Library namens ''Zod'' verwendet. Diese verwendet Builder Pattern um ein Validierungsschema zu bauen.
\begin{lstlisting}[caption=Validierungsschemen]
 import { z } from 'zod';

export const nameValidator = z.string().min(3);
export const emailValidator = z.string().email();
export const passwordValidator = z.string().min(6);
  
\end{lstlisting}


\section{Deployment}

\subsection{Allgemeins}

Die Veröffentlichung der Applikation im Play Store und im App Store wurde vom Team nicht verlangt.
Das Hochladen der Android-Applikation auf Firebase App Distribution war jedoch eine essentielle Aufgabe.
Das Backend wurde auf den Servern der Firmen Solvistas und Macolution deployt. Für Demonstrationszwecke wurde ein lokales Deployment auf Minikube erstellt.
% Die Firmen Solivstas und Macolution wollten das Endpordukt auf ihrer eigenen
% Infrastruktur deployen und die Anwendungen
% als Docker-Images in den Container-Registries von denen speichern.
% Da die genannten Firmen keine Zugriffsrechte für das Team organisiert haben,
% war es für das Team schwierig, beim finalen Deployment mitzumachen. Das Team hat aber die Möglichkeit gehabt,
% beim Deployment auf dem Stagingsystem mitzuhelfen, da die Software auf einem externen Service, nämlich
% Firebase App Distribution, hochgeladen wurde.
% Der Betreuer wurde ebenfalls informiert und er verlangte ein lokales Deployment für das Backend mittels ''Minikube'' sowie ein Live-Demo für die Applikation auf einem Emulator


% \subsubsection{Container Registry}

% \begin{quotation}
%   ``
%   A container registry is a repository—or collection of repositories—used to store and access container
%   images. Container registries can support container-based application development,
%   often as part of DevOps processes.
%   Container registries can connect directly to container orchestration platforms like Docker and Kubernetes.
%   ''
%   \cite{container-registry}
% \end{quotation}




\subsection{Deployment Diagram}
\begin{center}
  \includegraphics[width=\textwidth]{pics/dev-deployment.png}
\end{center}
\subsection{Deployment von dem Backend auf Minikube}

Damit ein funktionsfähiges Deployment erstellt werden kann, sind diese Komponenten zu deployen:
\begin{itemize}
  \item Strapi
  \item Datenbank
\end{itemize}

Für jede dieser genannten Bauteile des Backends sind Kubernetes (K8S) Deployments und Kubernetes Services zu erstellen.

\subsection{K8S-Konfigurationen für die Datenbank}
Zusätzlich zu einer Deployment- und Service-Komponente ist für die Sicherung
der Credentials der Datenbank eine sogenannte
Secret-Komponente nötig.
Für die Vermeidung von Datenverlusten in Fällen
wie Neustart eines Pods oder für die Aktualisierung
der Konfiguration des Pods ist
das Anlegen einer PersistenceVolume-Komponente sehr notwendig.
Damit das Deployment auf die PersistenceVolume-Komponente zugreifen kann, ist eine sogenannte PersistenceVolumeClaim-Komponente zu definieren.

Für die Konfiguration der Secret-, Service- und Deployment-Komponente wurde die kubectl \textbf{C}ommand \textbf{L}ine \textbf{I}nterface verwendet
und für die PersistenceVolume-Komponente bzw. die PersistenceVolumeClaim-Kompoente wurden fertige Konfigurationen genommen.
\begin{lstlisting}[caption=K8S PVC]
  apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    finalizers:
    - kubernetes.io/pvc-protection
    name: strapi-pvc
    namespace: default
  spec:
      accessModes:
        - ReadWriteMany
      resources:
        requests:
          storage: 10Mi
      storageClassName: standard
    
\end{lstlisting}


\begin{lstlisting}[caption=K8S PV]
  apiVersion: v1
  kind: PersistentVolume
  metadata:
    finalizers:
    - kubernetes.io/pv-protection
    labels:
      type: local
    name: strapi-volume
    resourceVersion: "33077"
    uid: ae6d772a-0090-4074-b3ac-1edb929daf29
  spec:
    accessModes:
    - ReadWriteOnce
    capacity:
      storage: 10Gi
    hostPath:
      path: /mnt/data
      type: ""
    persistentVolumeReclaimPolicy: Retain
    storageClassName: manual
    volumeMode: Filesystem
  status:
    phase: Available
    
\end{lstlisting}



\subsection{K8S-Konfigurationen für Strapi}
Für Strapi wird auch eine Secret-Komponente benötigt, da der Server geheime Umgebungsvariablen benötigt.

Damit das Deployment von Strapi erstellt werden kann, muss die Anwendung zuerst in ein Docker Image umgewandelt werden. Dies kann mit der Verwendung des folgenden Dockerfiles erfolgen.
\begin{lstlisting}[caption=Strapi Dockerfile]
  # Creating multi-stage build for production
  FROM node:18-alpine as build
  RUN apk update && apk add --no-cache build-base gcc autoconf automake zlib-dev libpng-dev vips-dev git > /dev/null 2>&1
  ARG NODE_ENV=production
  ENV NODE_ENV=${NODE_ENV}
  
  WORKDIR /opt/
  COPY package.json package-lock.json ./
  RUN npm install -g node-gyp
  RUN npm config set fetch-retry-maxtimeout 600000 -g && npm install --only=production
  ENV PATH /opt/node_modules/.bin:$PATH
  WORKDIR /opt/app
  COPY . .
  RUN npm run build
  # Creating final production image
  FROM node:18-alpine
  RUN apk add --no-cache vips-dev
  ARG NODE_ENV=production
  ENV NODE_ENV=${NODE_ENV}
  ENV HOST=0.0.0.0
  ENV PORT=1337
  ENV APP_KEYS=secret
  ENV API_TOKEN_SALT=secret
  ENV ADMIN_JWT_SECRET=secret
  ENV TRANSFER_TOKEN_SALT=secret
  # Database
  
  # Database
  ENV DATABASE_CLIENT=postgres
  ENV DATABASE_HOST=localhost
  ENV DATABASE_PORT=5432
  ENV DATABASE_NAME=strapi
  ENV DATABASE_USERNAME=strapi
  ENV DATABASE_PASSWORD=strapi
  ENV DATABASE_SSL=false
  ENV JWT_SECRET=cVRog3q5woTNB8EJ+vKPFA==
  
  
  
  
  WORKDIR /opt/
  COPY --from=build /opt/node_modules ./node_modules
  WORKDIR /opt/app
  COPY --from=build /opt/app ./
  ENV PATH /opt/node_modules/.bin:$PATH
  
  RUN chown -R node:node /opt/app
  USER node
  EXPOSE 1337
  CMD ["npm", "run", "start"]
    
\end{lstlisting}

Dieses Image soll dann in einem Container Registry wie zum Beispiel
Dockerhub oder Github Container Registry hochgeladen werden,
damit die K8S-Deployment-Komponente dieses Image in Einsatz nimmt.




\subsection{K8S-Secrets}
Damit man Umgebungsvariablen in einem K8S-Cluster definieren kann, gibt es zwei Möglichkeiten.
Man kann entweder eine ConfigMap-Komponente verwenden oder eine Secret-Komponente. Es gibt auch die Möglichkeit, diese Umgebungsvariablen direkt in den Konfigurationen von der Deployment-Komponente händisch einzutragen.
Für geheime bzw. sensible Daten werden K8S-Secrets verwendet.
Das Anlegen der benötigten Secrets für unsere Anwendung erfolgte durch die Verwendung folgender Befehle:
\begin{lstlisting}[caption=Secrets für Strapi]
    kubectl create secret generic strapi-server-secret \
  --from-literal=PORT=1337 \  
  --from-literal=APP_KEYS=secret
  --from-literal=API_TOKEN_SALT=secret \
  --from-literal=ADMIN_JWT_SECRET=secret \
  --from-literal=TRANSFER_TOKEN_SALT=secret \
  --from-literal=DATABASE_CLIENT=postgres \
  --from-literal=DATABASE_PORT=5432 \
  --from-literal=DATABASE_NAME=secret \
  --from-literal=DATABASE_USERNAME=secret \
  --from-literal=DATABASE_PASSWORD=secret \
  --from-literal=DATABASE_SSL=false \
  --from-literal=JWT_SECRET=secret
\end{lstlisting}


\begin{lstlisting}[caption=Secrets für die Datenbank]
kubectl create secret generic  strapi-secret \
--from-literal=POSTGRES_USER=strapi \
--from-literal=POSTGRES_PASSWORD=strapi \
--from-literal=POSTGRES_DB=strapi
\end{lstlisting}








\subsection{Was ist eine Deployment-Komponente}

Eine Deployment-Komponente dient dazu, dass ein Pod erstellt wird und die benötigten Ressourcen bzw. Volumes und Zugriffsrechte
dafür definiert werden.\cite{k8s-deployment}

Für das Anlegen einer Deployment-Komponente muss man zuerst die Anwendung containerisieren.
Für weit verbreitete Software wie z.B.: PostgreSQL gibt es bereits viele vorhandene Images auf unterschiedliche Container-Registries.

Folgende Befehle wurden verwendet, um die Deployment-Komponenten für Strapi und PostgreSQL zu erstellen:

\begin{lstlisting}[language=bash, caption=create k8s deployments]
kubectl create deployment relaxoon-db --image=postgres:12.16-bullseye --port=5432
kubectl create deployment relaxoon-strapi --image=ghcr.io/Abdulrahman-AL-Sabagh/relaxoon-strapi:latest --port=8080
    
\end{lstlisting}


\subsubsection{Was ist ein Pod}
''Ein Pod (übersetzt Gruppe/Schote, wie z. B. eine Gruppe von Walen oder eine Erbsenschote)
ist eine Gruppe von einem oder mehreren Containern mit gemeinsam genutzten Speicher- und
Netzwerkressourcen und einer Spezifikation für die Ausführung der Container.
Die Ressourcen eines Pods befinden sich immer auf dem gleichen (virtuellen) Server,
werden gemeinsam geplant und in einem gemeinsamen Kontext ausgeführt.
Ein Pod modelliert einen anwendungsspezifischen ''logischen Server'': Er enthält eine oder mehrere
containerisierte Anwendungen, die relativ stark voneinander abhängen.
''
\cite{pod}






\subsection{Erstellung einer Service-Komponente}

Mit dem Einsatz eines Services in Kubernetes können Pods,
die sich im gleichen Cluster befinden, miteinander kommunizieren. \cite{k8s-service}

Für das Anlegen einer Service-Komponente kann man diesen Befehl nutzen:

\begin{lstlisting}[language=bash,caption=create a service component]
kubectl expose deployments/<Name des Pods> --port=5432
\end{lstlisting}






\subsection{Erstellung einer Ingress-Komponente}

Damit der Emulator, der sich außerhalb des lokalen Clusters von Minikube befindet,
mit dem deployten Backend kommunizieren kann,
ist das Anlegen einer Ingress notwendig. Ein Ingress Controller ist mehr oder weniger mit einem Reverse Proxy zu vergleichen.
Die Konfigurationen für den Ingress-Controller sind in dem folgenden Code-Snippet zu finden:

\begin{lstlisting}[caption=ingress-contrller]
  # see https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: relaxoon-ingress

spec:
  rules:
    - host: hello-world.info
      http:
        paths:
          - path: /relaxoon
            pathType: Prefix
            backend:
              service:
                name: relaxoon-strapi
                port:
                  number: 80
  
\end{lstlisting}




\subsubsection{Was ist eine Ingress-Komponente}
``
An ingress controller acts as a reverse proxy and load balancer.
It implements a Kubernetes Ingress.
The ingress controller adds a layer of abstraction to traffic routing,
accepting traffic from outside the Kubernetes platform and load balancing
it to Pods running inside the platform.

''
\cite{ingress}

\subsection{Buildprozess für das Frontend}

Damit man das Frontend deployt, muss man zuerst den nativen Android und IOS Code generieren.
Danach sollen die Android bzw. IOS Anwendungen mit einer IDE oder mit der Kommando-Zeile gebaut werden.
Um den nativen Code zu generieren ist Folgendes einzugeben:
\begin{lstlisting}[language=Bash,caption=generate android and IOS]
npx expo prebuild
\end{lstlisting}





\subsection{Erstellung einer .apk Datei}
Für Android wurde die .\textbf{A}ndroid \textbf{P}ac\textbf{K}age (apk)  mit dem Einsatz von gradle Wrapper generiert.
Folgendes muss installiert und richtig konfiguriert werden, damit  eine .apk Datei generierbar ist:



\begin{itemize}
  \item Java 11
  \item Installation von sdkmanager
  \item Lizenzen von sdkmanager müssen akzeptiert sein
  \item Installation von einer Android SDK
  \item Konfigurationen für JAVA\_HOME und ANDROID\_HOME
  \item Installation einer CLI namens ''ninja''
\end{itemize}

Der Generierungsbefehl für die Build-Datei schaut dann wie folgt aus:

\begin{lstlisting}[language=bash,caption=generate apk]
 ./gradlew assembleRelease
 \end{lstlisting}





\section{Hochladen einer Mobileapp auf Firebase App Distribution}

Nach dem Anlegen eines Accuonts bei Firebase sind folgende Schritte zu machen:

Damit die benötigten Firebase Services für die Applikationen aktiviert werden, muss man zuerst die benötigten Konfigurationen eingeben.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{./pics/firebase1.png}
  \caption{create android config}
\end{figure}


Folgende Daten müssen eingegeben werden, damit die Firebase Services für die Android Applikation eingeschaltet werden können.

\begin{figure}[H]

  \includegraphics[width=\textwidth]{./pics/firebase2.png}
  \caption{Android Config}
\end{figure}

Die restlichen Punkte sind für das Projekt Relaxoon irrelevant,
da die Firebase-SDK in der vorligenden Arbeit nicht eingesetzt wird.


Danach soll man auf die App Distribution gehen und dann auf ''Get Started'' klicken.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{./pics/firebase3.png}
  \caption{App Distribution}
\end{figure}

Die App kann mit diesem ''Browser Fenster'' oder mit ''Drag and Drop'' hochgeladen werden.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{./pics/firebase4.png}
  \caption{App Upload}

\end{figure}


Das Produkt kann dann an andere Testuser:innen verteilt werden, indem man die Email-Adressen dieser
Tester:innen beim Release eingibt.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{./pics/firebase5.png}
  \caption{Releases}


\end{figure}



